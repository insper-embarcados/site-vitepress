import{_ as o,c as a,o as s,ae as i}from"./chunks/framework.fqSCwWg6.js";const m=JSON.parse('{"title":"Regras","description":"","frontmatter":{},"headers":[],"relativePath":"qualidade/rules.md","filePath":"qualidade/rules.md"}'),c={name:"qualidade/rules.md"};function d(t,e,r,l,p,n){return s(),a("div",null,e[0]||(e[0]=[i('<h1 id="regras" tabindex="-1">Regras <a class="header-anchor" href="#regras" aria-label="Permalink to &quot;Regras&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">Rule 1.0</p><p>O código não deve possuir erros detectados pelo <code>cppcheck</code>.</p><p><strong>Racional:</strong> Removendo erros detectado pelo analisador estático facilita a depuração e faz com o que projeto funcione mais rapidamente.</p></div><div class="tip custom-block"><p class="custom-block-title">Rule 1.1</p><p>Somente usar variáveis globais para passar informações de uma interrupção (ISR) para a função <code>main</code>.</p><p><strong>Racional:</strong> Está regra evita que você use variáveis globais onde elas poderiam ser locais.</p></div><div class="tip custom-block"><p class="custom-block-title">Rule 1.2</p><p>Todas as variáveis globais acessadas de uma interrupção (ISR) devem possuir a keyword: <code>volatile</code></p><p><strong>Racional:</strong> O volatile indica para o compilador não otimizar a variável em questão que está sendo modificada por um evento gerado pelo hardware e que o compilador não tem conhecimento.</p></div><div class="tip custom-block"><p class="custom-block-title">Rule 1.3</p><p>Somente as variáveis globais e modificadas durante a ISR devem ser globais.</p><p><strong>Racional:</strong> Devemos deixar o compilador fazer o papel dele e otimizar as variáveis que devem ser otimizadas.</p></div><div class="warning custom-block"><p class="custom-block-title">Rule 2.0</p><p>Todo <em>head file</em> (<code>.h</code>) deve ser criado com include guard.</p></div><div class="warning custom-block"><p class="custom-block-title">Rule 2.1</p><p>Não ter implementação de código em <em>head file</em> (<code>.h</code>).</p></div><div class="info custom-block"><p class="custom-block-title">RULE 3.0</p><p>Não pode usar / gerar <code>delay</code> de software dentro de uma ISR.</p></div><div class="info custom-block"><p class="custom-block-title">RULE 3.1</p><p>Não pode acessar o OLED ou qualquer outro display de dentro de uma ISR.</p></div><div class="info custom-block"><p class="custom-block-title">RULE 3.2</p><p>Não pode usar <code>printf</code> ou <code>sprintf</code> de dentro de uma ISR.</p></div><div class="info custom-block"><p class="custom-block-title">RULE 3.3</p><p>Não pode executar laços de código (<code>while</code>, <code>for</code>) de dentro de uma ISR.</p><p><strong>Racional:</strong> A ideia é que a ISR seja a mais simples e rápida possível, esse conjunto de regras evita o básico de tornar um código de ISR complexo e lento.</p></div>',11)]))}const v=o(c,[["render",d]]);export{m as __pageData,v as default};
